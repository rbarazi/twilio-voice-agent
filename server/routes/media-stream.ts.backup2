import { FastifyInstance } from 'fastify';
import WebSocket from 'ws';
import { RealtimeSession } from '@openai/agents/realtime';
import { TwilioRealtimeTransportLayer } from '@openai/agents-extensions';
import { logger } from '../utils/logger.js';
import { getAgentForTask } from '../agents/index.js';
import { callManager } from '../services/call-manager.js';

// Adapter to make Node.js ws WebSocket compatible with browser WebSocket API
function createBrowserStyleWebSocket(nodeSocket: WebSocket): any {
  return {
    send: (data: any) => nodeSocket.send(data),
    close: () => nodeSocket.close(),
    addEventListener: (event: string, handler: any) => {
      if (event === 'message') {
        nodeSocket.on('message', (data: Buffer) => {
          // Debug: log start events to verify streamSid
          try {
            const parsed = JSON.parse(data.toString());
            if (parsed.event === 'start') {
              logger.info('ðŸ” Adapter forwarding start event to transport', {
                streamSid: parsed.start?.streamSid,
                callSid: parsed.start?.callSid
              });
            }
          } catch (e) {
            // Ignore parse errors
          }
          handler({ data }); // Pass buffer as-is
        });
      } else if (event === 'close') {
        nodeSocket.on('close', handler);
      } else if (event === 'error') {
        nodeSocket.on('error', handler);
      }
    },
    removeEventListener: (event: string, handler: any) => {
      nodeSocket.off(event, handler);
    },
  };
}

export async function mediaStreamRoutes(fastify: FastifyInstance) {
  fastify.get('/twilio/media-stream', { websocket: true }, async (socket: WebSocket) => {
    logger.info('WebSocket connection established');

    let session: RealtimeSession | null = null;
    let callSid: string | null = null;
    let isInitialized = false;

    // Create transport layer FIRST, before processing any messages
    const browserSocket = createBrowserStyleWebSocket(socket);
    const transport = new TwilioRealtimeTransportLayer({
      twilioWebSocket: browserSocket,
    });

    // Listen for Twilio start event from transport to initialize session
    transport.on('*', async (event: any) => {
      if (event.type === 'twilio_message' && event.message?.event === 'start' && !isInitialized) {
        isInitialized = true;
        callSid = event.message.start.callSid;
        const streamSid = event.message.start.streamSid;
        logger.info('Media stream started via transport', { callSid, streamSid });

        // Get call metadata to determine which agent to use
        const callMetadata = callManager.getCall(callSid);

        // Create agent - use task from metadata if available, otherwise default
        const agent = callMetadata?.task
          ? getAgentForTask(callMetadata.task)
          : getAgentForTask({
              type: 'custom',
              prompt: 'You are a helpful AI assistant. Greet the caller and ask how you can help them.',
              context: {}
            });

        // Add send interceptor to log outgoing audio
        const originalSend = socket.send.bind(socket);
        let audioPacketCount = 0;
        socket.send = (data: any) => {
          try {
            const parsed = JSON.parse(data);
            if (parsed.event === 'media') {
              audioPacketCount++;
              if (audioPacketCount <=  3) {
                logger.info('ðŸ“¤ Sending audio to Twilio', {
                  callSid,
                  streamSid: parsed.streamSid,
                  payloadLength: parsed.media?.payload?.length || 0,
                  packetNum: audioPacketCount
                });
              }
            }
          } catch (e) {
            // Not JSON, ignore
          }
          return originalSend(data);
        };

        // Create session using the transport we already created
        logger.info('Creating RealtimeSession...', { callSid, agentName: agent.name });

          try {
            // Verify API key
            if (!process.env.OPENAI_API_KEY) {
              throw new Error('OPENAI_API_KEY is not set');
            }

            logger.info('Creating session with API key length', {
              callSid,
              keyLength: process.env.OPENAI_API_KEY.length,
              keyPrefix: process.env.OPENAI_API_KEY.substring(0, 8)
            });

            session = new RealtimeSession(agent, {
              transport,
              model: 'gpt-realtime',
              config: {
                inputAudioTranscription: {
                  model: 'whisper-1',
                },
              },
            });

            logger.info('RealtimeSession instance created', { callSid });

            // Add comprehensive error handling
            session.on('error', (error: Error) => {
              logger.error('RealtimeSession error', {
                callSid,
                error: error.message,
                stack: error.stack,
                name: error.name
              });
            });

            session.on('connected', () => {
              logger.info('âœ… RealtimeSession connected to OpenAI!', { callSid });
            });

            session.on('disconnected', () => {
              logger.info('RealtimeSession disconnected from OpenAI', { callSid });
            });

            // Listen to transport status changes
            session.on('transport_event', (event: any) => {
              if (event.type === 'twilio_message') {
                // Don't log every media event
                if (event.message?.event !== 'media') {
                  logger.info('Twilio message via transport_event', {
                    callSid,
                    event: event.message?.event
                  });
                }
              } else if (event.type === 'response.audio_transcript.done') {
                logger.info('ðŸ—£ï¸  AI said:', { callSid, transcript: event.transcript });
              } else if (event.type === 'conversation.item.input_audio_transcription.completed') {
                logger.info('ðŸ‘¤ User said:', { callSid, transcript: event.transcript });
              } else if (event.type === 'response.audio.delta') {
                // Log first audio chunk of each response
                logger.info('ðŸ”Š Sending audio to Twilio', { callSid, bytes: event.delta?.length || 0 });
              } else {
                // Don't log every audio delta
                if (!event.type.includes('.delta')) {
                  logger.info('Transport event via session', { callSid, eventType: event.type });
                }
              }
            });

            // **CRITICAL**: Wait for transport to process start event before connecting
            // Give the transport a moment to capture the streamSid from the start event
            await new Promise(resolve => setTimeout(resolve, 100));

            logger.info('Calling session.connect()...', { callSid });
            await session.connect({
              apiKey: process.env.OPENAI_API_KEY!,
            });
            logger.info('session.connect() completed', { callSid });

            // Update call status
            if (callMetadata) {
              callManager.updateCallStatus(callSid, 'in-progress');
            }

            logger.info('RealtimeSession setup complete and connected', {
              callSid,
              agent: agent.name
            });
          } catch (error) {
            logger.error('Failed to create RealtimeSession', {
              callSid,
              error: error instanceof Error ? error.message : String(error),
              stack: error instanceof Error ? error.stack : undefined,
              name: error instanceof Error ? error.name : 'Unknown'
            });
            throw error;
          }
        }

        if (data.event === 'stop') {
          logger.info('Media stream stopped', { callSid });

          // Session will be cleaned up when WebSocket closes
          session = null;

          if (callSid) {
            callManager.updateCallStatus(callSid, 'completed');
            callManager.removeCall(callSid);
          }
        }
      } catch (error) {
        logger.error('Error processing WebSocket message', error);
      }
    });

    socket.on('close', () => {
      logger.info('WebSocket connection closed', { callSid });

      // Cleanup
      session = null;

      if (callSid) {
        callManager.removeCall(callSid);
      }
    });

    socket.on('error', (error) => {
      logger.error('WebSocket error', error);
    });
  });
}
